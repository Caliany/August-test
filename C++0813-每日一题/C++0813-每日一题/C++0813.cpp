/*
每日总结：
1、IPV4版本的因特网共有126种有效的A类地址；
2、关于ARP表，用于建立IP地址到MAC地址的映射；
3、ARP协议被用来找到本地设备的硬件地址；
4、网络延迟：指从报文进入网络到它开始离开网络之间的时间。
*/

/*
编程题：蘑菇阵
现在有两个好友A和B，住在一片长有蘑菇的由n＊m个方格组成的草地，A在(1,1)，B在(n,m)。
现在A想要拜访B，由于她只想去B的家，所以每次她只会走(i,j+1)或(i+1,j)这样的路线，在
草地上有k个蘑菇种在格子里(多个蘑菇可能在同一方格),问：A如果每一步随机选择的话(若她
在边界上，则只有一种选择)，那么她不碰到蘑菇走到B的家的概率是多少？
第一行N，M，K(2 ≤ N,M ≤ 20, k ≤ 100),N,M为草地大小，接下来K行，每行两个整数x，y，代表(x,y)处有一个蘑菇。

【解题思路】：运用动态规划的算法

dp[i][j]表示不碰蘑菇走到i,j位置的概率。有向下走，向右走，两种状态。
(i,j)位置的概率由(i-1,j)与(i,j-1)决定。
对于在边界的情况:

i=N,j≠M，我们可以知道在(i,j-1)位置，只能向右走，不能向下走了，所以(i,j-1)向右走的概率为1，
而对于(i-1,j)这个位置就不受影响，它可以向下走，也可以向右走，所以(i-1,j)向下走到(i,j)的概率为0.5。
dp[i][j] = dp[i - 1][j] * 0.5 + dp[i][j - 1];

i≠N，j=M，我们可以知道在(i-1,j)位置，只能向下走，不能向右走了，所以(i-1，j)向下走的概率为1，
而对于(i,j-1)这个位置就不受影响了，可以向下，也可以向上，所以(i,j-1)向右走到(i,j)的概率为0.5。
dp[i][j] =dp[i - 1][j] + dp[i][j - 1] * 0.5;

T-T对于边界情况，写代码的时候，把i=N && j=M的情况掉了，找了好久
在这种情况下决定dp[i][j]的两个位置(i-1,j)只能向下走，(i，j-1)只能向右走。
dp[i][j] = dp[i - 1][j] + dp[i][j - 1]；

*/
#include <iostream>
#include <stdlib.h>
#include <stdio.h>

using namespace std;

int main()
{
	int n, m, k;
	double dp[20][20];
	int map[20][20];
	while (cin >> n >> m >> k)
	{
		for (int i = 0; i < 20; i++)
		for (int j = 0; j < 20; j++)
		{
			dp[i][j] = 0;
			map[i][j] = false;
		}

		int x, y;
		for (int i = 0; i < k; i++)
		{
			cin >> x >> y;
			map[x - 1][y - 1] = true;
		}

		dp[0][0] = 1;
		for (int i = 0; i < n; i++)
		for (int j = 0; j < m; j++)
		{
			if (i == 0 && j == 0)    continue;
			if (map[i][j])
			{
				dp[i][j] = 0;
			}
			else if (n>1 && i == 0)
			{
				dp[i][j] = 0.5* dp[i][j - 1];
			}
			else if (m > 1 && j == 0)
			{
				dp[i][j] = 0.5* dp[i - 1][j];
			}
			else
			{
				dp[i][j] = (i == (n - 1) ? 1 : 0.5) * dp[i][j - 1] + (j == (m - 1) ? 1 : 0.5) * dp[i - 1][j];
			}
		}
		printf("%.2f\n", dp[n - 1][m - 1]);
	}
	return 0;
}